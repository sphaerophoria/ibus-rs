// This file was generated by gir (https://github.com/gtk-rs/gir @ a6737c7)
// from gir-files (https://github.com/gtk-rs/gir-files @ ???)
// DO NOT EDIT

use glib::object::IsA;
use glib::translate::*;
use glib::GString;
use glib::StaticType;
use glib::Value;
use gobject_sys;
use ibus_sys;
use std::fmt;
use EngineDesc;

glib_wrapper! {
    pub struct Component(Object<ibus_sys::IBusComponent, ibus_sys::IBusComponentClass, ComponentClass>);

    match fn {
        get_type => || ibus_sys::ibus_component_get_type(),
    }
}

impl Component {
    pub fn new(name: &str, description: &str, version: &str, license: &str, author: &str, homepage: &str, command_line: &str, textdomain: &str) -> Component {
        unsafe {
            from_glib_none(ibus_sys::ibus_component_new(name.to_glib_none().0, description.to_glib_none().0, version.to_glib_none().0, license.to_glib_none().0, author.to_glib_none().0, homepage.to_glib_none().0, command_line.to_glib_none().0, textdomain.to_glib_none().0))
        }
    }

    pub fn from_file(filename: &str) -> Component {
        unsafe {
            from_glib_none(ibus_sys::ibus_component_new_from_file(filename.to_glib_none().0))
        }
    }

    //pub fn from_xml_node(node: /*Ignored*/&mut XML) -> Component {
    //    unsafe { TODO: call ibus_sys:ibus_component_new_from_xml_node() }
    //}

    //pub fn new_varargs(first_property_name: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Component {
    //    unsafe { TODO: call ibus_sys:ibus_component_new_varargs() }
    //}
}

pub const NONE_COMPONENT: Option<&Component> = None;

pub trait ComponentExt: 'static {
    fn add_engine<P: IsA<EngineDesc>>(&self, engine: &P);

    fn add_observed_path(&self, path: &str, access_fs: bool);

    fn check_modification(&self) -> bool;

    fn get_author(&self) -> Option<GString>;

    fn get_description(&self) -> Option<GString>;

    fn get_engines(&self) -> Vec<EngineDesc>;

    fn get_exec(&self) -> Option<GString>;

    fn get_homepage(&self) -> Option<GString>;

    fn get_license(&self) -> Option<GString>;

    fn get_name(&self) -> Option<GString>;

    //fn get_observed_paths(&self) -> /*Ignored*/Vec<ObservedPath>;

    fn get_textdomain(&self) -> Option<GString>;

    fn get_version(&self) -> Option<GString>;

    //fn output(&self, output: /*Ignored*/&mut glib::String, indent: i32);

    //fn output_engines(&self, output: /*Ignored*/&mut glib::String, indent: i32);

    fn get_property_command_line(&self) -> Option<GString>;
}

impl<O: IsA<Component>> ComponentExt for O {
    fn add_engine<P: IsA<EngineDesc>>(&self, engine: &P) {
        unsafe {
            ibus_sys::ibus_component_add_engine(self.as_ref().to_glib_none().0, engine.as_ref().to_glib_none().0);
        }
    }

    fn add_observed_path(&self, path: &str, access_fs: bool) {
        unsafe {
            ibus_sys::ibus_component_add_observed_path(self.as_ref().to_glib_none().0, path.to_glib_none().0, access_fs.to_glib());
        }
    }

    fn check_modification(&self) -> bool {
        unsafe {
            from_glib(ibus_sys::ibus_component_check_modification(self.as_ref().to_glib_none().0))
        }
    }

    fn get_author(&self) -> Option<GString> {
        unsafe {
            from_glib_none(ibus_sys::ibus_component_get_author(self.as_ref().to_glib_none().0))
        }
    }

    fn get_description(&self) -> Option<GString> {
        unsafe {
            from_glib_none(ibus_sys::ibus_component_get_description(self.as_ref().to_glib_none().0))
        }
    }

    fn get_engines(&self) -> Vec<EngineDesc> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ibus_sys::ibus_component_get_engines(self.as_ref().to_glib_none().0))
        }
    }

    fn get_exec(&self) -> Option<GString> {
        unsafe {
            from_glib_none(ibus_sys::ibus_component_get_exec(self.as_ref().to_glib_none().0))
        }
    }

    fn get_homepage(&self) -> Option<GString> {
        unsafe {
            from_glib_none(ibus_sys::ibus_component_get_homepage(self.as_ref().to_glib_none().0))
        }
    }

    fn get_license(&self) -> Option<GString> {
        unsafe {
            from_glib_none(ibus_sys::ibus_component_get_license(self.as_ref().to_glib_none().0))
        }
    }

    fn get_name(&self) -> Option<GString> {
        unsafe {
            from_glib_none(ibus_sys::ibus_component_get_name(self.as_ref().to_glib_none().0))
        }
    }

    //fn get_observed_paths(&self) -> /*Ignored*/Vec<ObservedPath> {
    //    unsafe { TODO: call ibus_sys:ibus_component_get_observed_paths() }
    //}

    fn get_textdomain(&self) -> Option<GString> {
        unsafe {
            from_glib_none(ibus_sys::ibus_component_get_textdomain(self.as_ref().to_glib_none().0))
        }
    }

    fn get_version(&self) -> Option<GString> {
        unsafe {
            from_glib_none(ibus_sys::ibus_component_get_version(self.as_ref().to_glib_none().0))
        }
    }

    //fn output(&self, output: /*Ignored*/&mut glib::String, indent: i32) {
    //    unsafe { TODO: call ibus_sys:ibus_component_output() }
    //}

    //fn output_engines(&self, output: /*Ignored*/&mut glib::String, indent: i32) {
    //    unsafe { TODO: call ibus_sys:ibus_component_output_engines() }
    //}

    fn get_property_command_line(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"command-line\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `command-line` getter")
        }
    }
}

impl fmt::Display for Component {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Component")
    }
}
